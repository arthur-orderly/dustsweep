<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DustSweep ‚Äî Clean Your Wallet Dust</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßπ</text></svg>">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<style>
:root {
    --bg: #0a0a0f; --card: #13131a; --card-hover: #1a1a24; --border: #1e1e2a;
    --text: #e4e4e7; --text-dim: #71717a; --accent: #8b5cf6; --accent-light: #a78bfa;
    --accent-glow: rgba(139,92,246,0.15); --green: #22c55e; --green-dim: rgba(34,197,94,0.1);
    --red: #ef4444; --orange: #f59e0b; --blue: #3b82f6;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family:'Inter',-apple-system,sans-serif; background:var(--bg); color:var(--text); min-height:100vh; }
body::before { content:''; position:fixed; top:-50%; left:-50%; width:200%; height:200%;
    background:radial-gradient(circle at 30% 20%,rgba(139,92,246,0.04) 0%,transparent 50%),
    radial-gradient(circle at 70% 80%,rgba(59,130,246,0.03) 0%,transparent 50%); z-index:-1; }
.header { display:flex; justify-content:space-between; align-items:center; padding:20px 40px;
    border-bottom:1px solid var(--border); backdrop-filter:blur(20px); position:sticky; top:0; z-index:100;
    background:rgba(10,10,15,0.8); }
.logo { display:flex; align-items:center; gap:10px; font-size:1.4rem; font-weight:800; }
.logo-icon { width:36px; height:36px; background:linear-gradient(135deg,var(--accent),#3b82f6);
    border-radius:10px; display:flex; align-items:center; justify-content:center; font-size:1.2rem; }
.logo span { color:var(--accent-light); }
.powered-by { font-size:0.7rem; color:var(--text-dim); }
.btn { background:var(--accent); color:white; border:none; padding:10px 24px; border-radius:12px;
    font-size:0.85rem; font-weight:600; cursor:pointer; transition:all 0.2s; font-family:inherit; }
.btn:hover { background:var(--accent-light); transform:translateY(-1px); }
.btn.connected { background:var(--green-dim); color:var(--green); border:1px solid rgba(34,197,94,0.2); }
.main { max-width:680px; margin:0 auto; padding:40px 20px; }
.hero { text-align:center; margin-bottom:40px; }
.hero h1 { font-size:2.8rem; font-weight:900; letter-spacing:-1.5px; margin-bottom:12px;
    background:linear-gradient(135deg,#fff 30%,var(--accent-light)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.hero p { font-size:1.05rem; color:var(--text-dim); max-width:480px; margin:0 auto; line-height:1.6; }
.card { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:20px; margin-bottom:20px; }
.stats-bar { display:flex; gap:12px; margin-bottom:24px; }
.stat-card { flex:1; background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; text-align:center; }
.stat-value { font-size:1.5rem; font-weight:800; }
.stat-value.purple { color:var(--accent-light); }
.stat-value.green { color:var(--green); }
.stat-value.orange { color:var(--orange); }
.stat-label { font-size:0.7rem; color:var(--text-dim); margin-top:4px; text-transform:uppercase; letter-spacing:0.5px; }
.chain-tabs { display:flex; gap:6px; margin-bottom:16px; overflow-x:auto; padding-bottom:4px; }
.chain-tab { padding:8px 14px; border-radius:10px; font-size:0.75rem; font-weight:600; cursor:pointer;
    border:1px solid var(--border); background:var(--card); color:var(--text-dim); white-space:nowrap;
    transition:all 0.2s; font-family:inherit; }
.chain-tab:hover { border-color:var(--accent); color:var(--text); }
.chain-tab.active { background:var(--accent-glow); border-color:var(--accent); color:var(--accent-light); }
.dust-list { max-height:500px; overflow-y:auto; }
.dust-list::-webkit-scrollbar { width:4px; }
.dust-list::-webkit-scrollbar-thumb { background:var(--border); border-radius:4px; }
.dust-item { display:flex; align-items:center; padding:12px 16px; border-bottom:1px solid rgba(30,30,42,0.5);
    transition:background 0.15s; cursor:pointer; }
.dust-item:hover { background:var(--card-hover); }
.dust-item.selected { background:rgba(139,92,246,0.05); }
.dust-item .check { width:18px; height:18px; border:2px solid var(--border); border-radius:5px;
    margin-right:14px; display:flex; align-items:center; justify-content:center; font-size:0.6rem; flex-shrink:0; }
.dust-item.selected .check { background:var(--accent); border-color:var(--accent); }
.dust-item .icon { width:34px; height:34px; border-radius:50%; margin-right:12px; display:flex;
    align-items:center; justify-content:center; font-size:0.7rem; font-weight:700; flex-shrink:0; overflow:hidden; }
.dust-item .icon img { width:100%; height:100%; }
.dust-item .info { flex:1; min-width:0; }
.dust-item .name { font-size:0.85rem; font-weight:600; display:flex; align-items:center; gap:6px; }
.dust-item .name .badge { font-size:0.55rem; padding:2px 5px; border-radius:4px; background:rgba(59,130,246,0.1); color:var(--blue); }
.dust-item .bal { font-size:0.7rem; color:var(--text-dim); margin-top:2px; }
.dust-item .val { text-align:right; flex-shrink:0; font-size:0.85rem; font-weight:600; }
.dust-item .val.dim { color:var(--text-dim); font-size:0.7rem; }
.dust-item .mint { font-size:0.6rem; color:var(--text-dim); word-break:break-all; }
.config-row { display:flex; gap:12px; margin-bottom:12px; }
.config-option { flex:1; padding:14px; border:1px solid var(--border); border-radius:12px; cursor:pointer;
    text-align:center; transition:all 0.2s; background:var(--bg); font-family:inherit; }
.config-option:hover { border-color:var(--accent); }
.config-option.active { border-color:var(--accent); background:var(--accent-glow); }
.config-option .tn { font-size:0.85rem; font-weight:700; }
.config-option .td { font-size:0.65rem; color:var(--text-dim); }
.summary-row { display:flex; justify-content:space-between; padding:6px 0; font-size:0.85rem; }
.summary-row .l { color:var(--text-dim); } .summary-row .v { font-weight:600; }
.summary-row.total { border-top:1px solid var(--border); margin-top:8px; padding-top:12px; font-size:1rem; }
.summary-row.total .v { color:var(--green); font-weight:800; }
.summary-row .fee { color:var(--orange); }
.sweep-btn { width:100%; padding:18px; border:none; border-radius:14px; font-size:1.1rem; font-weight:700;
    cursor:pointer; font-family:inherit; background:linear-gradient(135deg,var(--accent),#6366f1); color:white;
    transition:all 0.2s; }
.sweep-btn:hover { transform:translateY(-2px); box-shadow:0 8px 30px rgba(139,92,246,0.3); }
.sweep-btn:disabled { opacity:0.5; cursor:not-allowed; transform:none; box-shadow:none; }
.sweep-btn .sub { font-size:0.7rem; font-weight:400; opacity:0.7; display:block; margin-top:4px; }
.progress-bar { width:100%; height:4px; background:var(--border); border-radius:2px; margin-top:12px; overflow:hidden; display:none; }
.progress-bar .fill { height:100%; background:linear-gradient(90deg,var(--accent),var(--green)); border-radius:2px; transition:width 0.3s; width:0%; }
.sweep-log { margin-top:12px; max-height:200px; overflow-y:auto; font-size:0.75rem; line-height:1.8; }
.sweep-log .entry { padding:2px 0; display:flex; align-items:center; gap:8px; }
.sweep-log .entry.ok { color:var(--green); }
.sweep-log .entry.fail { color:var(--red); }
.sweep-log .entry.info { color:var(--text-dim); }
#debugLog { font-family:monospace; font-size:0.65rem; color:var(--text-dim); background:var(--bg);
    border:1px solid var(--border); border-radius:8px; padding:10px; max-height:200px; overflow-y:auto;
    margin-top:16px; line-height:1.6; word-break:break-all; display:none; }
.features { display:flex; gap:16px; margin-top:40px; }
.feature { flex:1; background:var(--card); border:1px solid var(--border); border-radius:14px; padding:20px; }
.feature-icon { font-size:1.5rem; margin-bottom:10px; }
.feature h3 { font-size:0.85rem; margin-bottom:6px; }
.feature p { font-size:0.75rem; color:var(--text-dim); line-height:1.5; }
.footer { text-align:center; padding:40px; color:var(--text-dim); font-size:0.7rem; border-top:1px solid var(--border); margin-top:60px; }
.footer a { color:var(--accent-light); text-decoration:none; }
.sel-bar { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--border); }
.sel-bar label { display:flex; align-items:center; gap:8px; font-size:0.8rem; color:var(--text-dim); cursor:pointer; }
.threshold select { background:var(--bg); border:1px solid var(--border); color:var(--text); padding:4px 8px;
    border-radius:6px; font-size:0.75rem; font-family:inherit; }
.connect-btns { display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
.connect-btns .btn { padding:14px 28px; font-size:1rem; }
.connect-btns .btn.sol { background:#9945FF; }
.connect-btns .btn.sol:hover { background:#b06aff; }
.loading-state { text-align:center; padding:60px 20px; }
.loading-state .spinner { width:40px; height:40px; border:3px solid var(--border); border-top-color:var(--accent);
    border-radius:50%; animation:spin 0.8s linear infinite; margin:0 auto 20px; }
@keyframes spin { to { transform:rotate(360deg); } }
.loading-state .text { color:var(--text-dim); font-size:0.9rem; animation:pulse 1.5s ease-in-out infinite; }
@keyframes pulse { 0%,100% { opacity:0.5; } 50% { opacity:1; } }
@media (max-width:640px) { .header{padding:16px 20px;} .hero h1{font-size:2rem;} .stats-bar,.features{flex-direction:column;} .connect-btns{flex-direction:column;} }
</style>
</head>
<body>
<header class="header">
    <div class="logo"><div class="logo-icon">üßπ</div>Dust<span>Sweep</span></div>
    <div style="display:flex;align-items:center;gap:16px;">
        <div class="powered-by">Solana via Jupiter ¬∑ EVM via Odos</div>
        <div id="walletDisplay" style="display:none;font-size:0.7rem;text-align:right;line-height:1.6;">
            <div id="evmWalletLine" style="display:none;">ü¶ä <span id="evmAddrShort"></span> <a href="#" onclick="disconnectEVM();return false" style="color:var(--text-dim);text-decoration:none;">‚úï</a></div>
            <div id="solWalletLine" style="display:none;">üëª <span id="solAddrShort"></span> <a href="#" onclick="disconnectSol();return false" style="color:var(--text-dim);text-decoration:none;">‚úï</a></div>
        </div>
        <button class="btn" id="addWalletBtn" style="display:none;background:transparent;border:1px solid var(--border);color:var(--text-dim);padding:6px 12px;font-size:0.7rem;" onclick="showAddWallet()">+ Add Wallet</button>
        <button class="btn" id="connectBtn" onclick="connectSolana()">Connect Wallet</button>
    </div>
</header>
<main class="main">
    <div class="hero">
        <h1>Sweep Your Dust</h1>
        <p>Find forgotten tokens across all your wallets. Swap and bridge them into one asset, one chain.</p>
    </div>

    <div id="preConnect">
        <div style="text-align:center;padding:40px;">
            <div style="width:80px;height:80px;background:var(--accent-glow);border:2px solid rgba(139,92,246,0.2);border-radius:24px;display:flex;align-items:center;justify-content:center;font-size:2rem;margin:0 auto 20px;">üëõ</div>
            <h2 style="font-size:1.3rem;margin-bottom:8px;">Connect your wallet to start</h2>
            <p style="color:var(--text-dim);font-size:0.9rem;margin-bottom:24px;">We'll scan for small token balances and help you clean them up</p>
            <div class="connect-btns">
                <button class="btn sol" onclick="connectSolana()">üëª Solana</button>
                <button class="btn" onclick="connectEVM()">ü¶ä EVM</button>
            </div>
            <p style="color:var(--text-dim);font-size:0.7rem;margin-top:12px;">Solana: Phantom ¬∑ EVM: Rabby, MetaMask (not Phantom EVM)</p>
            <div class="features">
                <div class="feature"><div class="feature-icon">üîç</div><h3>Deep Scan</h3><p>Finds all SPL tokens including pump.fun, Token-2022, and zero-value accounts.</p></div>
                <div class="feature"><div class="feature-icon">‚ö°</div><h3>Real Swaps</h3><p>Jupiter for Solana, Odos + Uniswap for EVM. Best execution. Free during beta.</p></div>
                <div class="feature"><div class="feature-icon">üîí</div><h3>Non-Custodial</h3><p>Sign each transaction in your wallet. We never touch your keys.</p></div>
            </div>
        </div>
    </div>

    <div id="debugLog"></div>

    <div id="postConnect" style="display:none;">
        <div id="loadingState" class="loading-state">
            <div class="spinner"></div>
            <div class="text" id="loadingText">Scanning your wallet...</div>
        </div>
        <div class="stats-bar" id="statsBar" style="display:none;margin-top:20px;">
            <div class="stat-card"><div class="stat-value purple" id="stTokens">0</div><div class="stat-label">Tokens Found</div></div>
            <div class="stat-card"><div class="stat-value green" id="stValue">$0</div><div class="stat-label">Recoverable</div></div>
            <div class="stat-card"><div class="stat-value orange" id="stChains">0</div><div class="stat-label">Chains</div></div>
        </div>

        <div class="chain-tabs" id="chainTabs" style="display:none;"></div>

        <div class="card" id="tokenPanel" style="display:none;padding:0;">
            <div class="sel-bar">
                <label><input type="checkbox" id="selAll" checked onchange="toggleAll()"> Select All</label>
                <div class="threshold">Show under <select id="thresh" onchange="render()">
                    <option value="1">$1</option><option value="5">$5</option><option value="10">$10</option>
                    <option value="20">$20</option><option value="50">$50</option><option value="100" selected>$100</option>
                </select></div>
            </div>
            <div class="dust-list" id="dustList"></div>
        </div>

        <div class="card" id="configPanel" style="display:none;">
            <div style="font-size:0.8rem;font-weight:600;color:var(--text-dim);margin-bottom:14px;text-transform:uppercase;">Sweep into</div>
            <div class="config-row">
                <div class="config-option active" data-dest="ETH-ARB" onclick="pickToken(this,'ETH-ARB')"><div class="tn">ETH</div><div class="td">‚Üí Arbitrum</div></div>
                <div class="config-option" data-dest="USDC-ARB" onclick="pickToken(this,'USDC-ARB')"><div class="tn">USDC</div><div class="td">‚Üí Arbitrum</div></div>
                <div class="config-option" data-dest="USDC-SOL" onclick="pickToken(this,'USDC-SOL')"><div class="tn">USDC</div><div class="td">‚Üí Solana</div></div>
                <div class="config-option" data-dest="SOL" onclick="pickToken(this,'SOL')"><div class="tn">SOL</div><div class="td">‚Üí Solana</div></div>

            </div>
        </div>

        <div class="card" id="summaryPanel" style="display:none;">
            <div class="summary-row"><span class="l">Selected tokens</span><span class="v" id="smTok">0</span></div>
            <div class="summary-row"><span class="l">Gross value</span><span class="v" id="smGross">$0</span></div>
            <div class="summary-row"><span class="l">Protocol fee</span><span class="v" id="smFee" style="color:var(--green);">Free (beta)</span></div>
            <div class="summary-row total"><span class="l">You receive</span><span class="v" id="smNet">$0</span></div>
        </div>

        <button class="sweep-btn" id="approveBtn" style="display:none;" onclick="doApproveAll()" disabled>
            üìù Approve All<span class="sub">Approve tokens for BatchSweeper contract</span>
        </button>
        <button class="sweep-btn" id="sweepBtn" style="display:none;" onclick="doSweep()" disabled>
            üßπ Sweep All<span class="sub">One transaction per chain</span>
        </button>
        <div class="progress-bar" id="progressBar"><div class="fill" id="progressFill"></div></div>
        <div class="sweep-log" id="sweepLog"></div>
    </div>
</main>
<footer class="footer">DustSweep ‚Äî Solana swaps via <a href="https://jup.ag" target="_blank">Jupiter</a> ¬∑ EVM swaps via <a href="https://odos.xyz" target="_blank">Odos</a> + <a href="https://uniswap.org" target="_blank">Uniswap</a> ¬∑ Free during beta</footer>

<script>
// === STATE ===
const COLORS = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD','#98D8C8','#F7DC6F','#BB8FCE','#85C1E9','#F0B27A','#82E0AA'];
let tokens = [], selected = new Set(), destToken = 'ETH-ARB', chainFilter = 'all', solRpc = null;
let connectedSolAddr = null, connectedEvmAddr = null;
let sweepPhase = 'idle'; // idle | approving | approved | sweeping

// === BATCH SWEEPER CONTRACT ===
const BATCH_SWEEPER = {
    'Arbitrum': '0x847E855967cC15793c8D19e5BbA964AdbD19CED1',
    'Base': '0xBbbBcE377172Cad7009F21C80089950eA7E214Df',
    'Ethereum': '0xa67C6e0C0Ce8215a1e01aFEB80Fed9d84a7fcA9B',
};
const BATCH_SWEEPER_CHAINS = {
    'Arbitrum': 42161,
    'Base': 8453,
    'Ethereum': 1,
};

// === DEBUG ===
const DEBUG = window.location.search.includes('debug');
if (DEBUG) document.getElementById('debugLog').style.display = 'block';
function log(msg) { console.log(msg); if (DEBUG) { const el = document.getElementById('debugLog'); if (el) { el.innerHTML += msg + '\n'; el.scrollTop = el.scrollHeight; } } }

// === SWEEP LOG (always visible during sweep) ===
function sweepLog(msg, type = 'info') {
    const el = document.getElementById('sweepLog');
    el.innerHTML += `<div class="entry ${type}">${type === 'ok' ? '‚úÖ' : type === 'fail' ? '‚ùå' : '‚è≥'} ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

// === UTILS ===
async function fetchT(url, opts = {}, ms = 15000) {
    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), ms);
    try {
        const r = await fetch(url, { ...opts, signal: ctrl.signal });
        clearTimeout(timer);
        return r;
    } catch(e) { clearTimeout(timer); throw e; }
}
function withTimeout(promise, ms, label) {
    return Promise.race([promise, new Promise((_, rej) => setTimeout(() => rej(new Error(label + ' timed out')), ms))]);
}
function showPost() {
    document.getElementById('preConnect').style.display = 'none';
    document.getElementById('postConnect').style.display = 'block';
}

// === WALLET DISPLAY ===
function updateWalletDisplay() {
    const wd = document.getElementById('walletDisplay');
    const evmLine = document.getElementById('evmWalletLine');
    const solLine = document.getElementById('solWalletLine');
    const addBtn = document.getElementById('addWalletBtn');
    const connectBtn = document.getElementById('connectBtn');

    if (connectedEvmAddr) {
        document.getElementById('evmAddrShort').textContent = connectedEvmAddr.slice(0, 6) + '...' + connectedEvmAddr.slice(-4);
        evmLine.style.display = 'block';
    } else {
        evmLine.style.display = 'none';
    }
    if (connectedSolAddr) {
        document.getElementById('solAddrShort').textContent = connectedSolAddr.slice(0, 4) + '...' + connectedSolAddr.slice(-4);
        solLine.style.display = 'block';
    } else {
        solLine.style.display = 'none';
    }

    const hasAny = connectedEvmAddr || connectedSolAddr;
    const hasBoth = connectedEvmAddr && connectedSolAddr;
    wd.style.display = hasAny ? 'block' : 'none';
    addBtn.style.display = (hasAny && !hasBoth) ? 'inline-block' : 'none';
    connectBtn.style.display = hasAny ? 'none' : 'inline-block';

    // Update destination options based on connected wallets
    updateDestOptions();
}

function updateDestOptions() {
    const hasEvm = !!connectedEvmAddr;
    const hasSol = !!connectedSolAddr;
    // Show/hide cross-chain-to-Solana options based on Solana wallet
    document.querySelectorAll('.config-option').forEach(el => {
        const token = el.getAttribute('data-dest');
        if (!token) return;
        if ((token === 'USDC-SOL' || token === 'SOL') && !hasSol && hasEvm) {
            el.style.opacity = '0.3';
            el.title = 'Connect a Solana wallet first';
        } else {
            el.style.opacity = '1';
            el.title = '';
        }
    });
}

function showAddWallet() {
    if (!connectedSolAddr) connectSolana();
    else if (!connectedEvmAddr) connectEVM();
}

async function disconnectEVM() {
    connectedEvmAddr = null;
    tokens = tokens.filter(t => t.chain === 'Solana');
    selected.clear();
    updateWalletDisplay();
    if (!connectedSolAddr) {
        document.getElementById('preConnect').style.display = 'block';
        document.getElementById('postConnect').style.display = 'none';
    } else {
        render();
    }
    log('EVM wallet disconnected');
}

async function disconnectSol() {
    try { const sol = window?.phantom?.solana || window?.solana; if (sol) await sol.disconnect(); } catch(e) {}
    connectedSolAddr = null;
    tokens = tokens.filter(t => t.chain !== 'Solana');
    selected.clear();
    updateWalletDisplay();
    if (!connectedEvmAddr) {
        document.getElementById('preConnect').style.display = 'block';
        document.getElementById('postConnect').style.display = 'none';
    } else {
        render();
    }
    log('Solana wallet disconnected');
}

// === WALLET CONNECT ===
async function connectSolana() {
    log('Connecting Solana wallet...');
    const sol = window?.phantom?.solana || window?.solana;
    if (!sol) { alert('No Solana wallet found. Install Phantom.'); return; }

    let addr = null;
    if (sol.isConnected && sol.publicKey) {
        addr = sol.publicKey.toString();
        log('‚úÖ Already connected: ' + addr);
    } else {
        try {
            const resp = await withTimeout(sol.connect({ onlyIfTrusted: true }), 5000, 'Silent');
            addr = resp.publicKey.toString();
            log('‚úÖ Silent: ' + addr);
        } catch(e) {
            try {
                log('Opening Phantom popup...');
                const resp = await withTimeout(sol.connect(), 30000, 'Phantom');
                addr = resp.publicKey.toString();
                log('‚úÖ Connected: ' + addr);
            } catch(e2) {
                alert('Phantom connect failed. Try clicking the Phantom icon first.');
                return;
            }
        }
    }
    connectedSolAddr = addr;
    updateWalletDisplay();
    showPost();
    await scan(connectedEvmAddr, addr);
}

async function connectEVM() {
    log('Connecting EVM wallet...');

    // Find a non-Phantom EVM provider (Rabby, MetaMask, etc.)
    let eth = null;

    // Check for multiple providers (EIP-5749)
    if (window.ethereum?.providers?.length) {
        eth = window.ethereum.providers.find(p => p.isRabby) ||
              window.ethereum.providers.find(p => p.isMetaMask && !p.isPhantom) ||
              window.ethereum.providers.find(p => !p.isPhantom);
        log('Found ' + window.ethereum.providers.length + ' EVM providers');
    }
    // Direct checks
    if (!eth && window.rabby) { eth = window.rabby; log('Using window.rabby'); }
    if (!eth && window.ethereum && !window.ethereum.isPhantom) { eth = window.ethereum; log('Using window.ethereum (non-Phantom)'); }

    if (!eth) {
        alert('No EVM wallet found.\n\nPhantom\'s EVM mode doesn\'t work with Solana-only accounts.\n\nInstall Rabby (rabby.io) or MetaMask for EVM chains.');
        return;
    }

    try {
        log('Requesting accounts from ' + (eth.isRabby ? 'Rabby' : eth.isMetaMask ? 'MetaMask' : 'EVM wallet') + '...');
        const accts = await withTimeout(eth.request({ method: 'eth_requestAccounts' }), 30000, 'EVM');
        const addr = accts[0];
        log('‚úÖ EVM: ' + addr);
        connectedEvmAddr = addr;
        updateWalletDisplay();
        showPost();
        await scan(addr, connectedSolAddr);
    } catch(e) { alert('EVM connect failed: ' + e.message); }
}

// === SCAN ===
async function scan(evmAddr, solAddr) {
    tokens = []; selected.clear();
    document.getElementById('loadingState').style.display = 'block';
    document.getElementById('statsBar').style.display = 'none';
    document.getElementById('chainTabs').style.display = 'none';
    document.getElementById('tokenPanel').style.display = 'none';
    document.getElementById('configPanel').style.display = 'none';
    document.getElementById('summaryPanel').style.display = 'none';
    document.getElementById('sweepBtn').style.display = 'none';
    document.getElementById('approveBtn').style.display = 'none';
    sweepPhase = 'idle';

    // === SOLANA ===
    if (solAddr) {
        log('--- Scanning Solana ---');
        document.getElementById('loadingText').textContent = 'Scanning Solana tokens...';
        const SOL_RPCS = ['https://solana-rpc.publicnode.com', 'https://api.mainnet-beta.solana.com', 'https://solana.drpc.org'];
        solRpc = 'proxy';

        // Use server-side proxy to avoid browser RPC timeouts
        let mintBals = [];
        try {
            log('Fetching via server proxy...');
            const proxyUrl = '/api/tokens?addr=' + encodeURIComponent(solAddr);
            const pr = await fetchT(proxyUrl, {}, 12000);
            if (pr.ok) {
                const data = await pr.json();
                log('‚úÖ Server returned ' + data.totalAccounts + ' accounts, ' + data.tokens.length + ' with balance');

                // Add SOL
                if (data.solBalance > 0.001) {
                    let price = 85;
                    try { const sp = await fetchT('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd', {}, 3000);
                        const spd = await sp.json(); price = spd?.solana?.usd || 85; } catch(e) {}
                    tokens.push({ symbol: 'SOL', name: 'Solana', chain: 'Solana', balance: data.solBalance, usd: data.solBalance * price, color: '#9945FF', mint: null, decimals: 9, isNative: true });
                }

                mintBals = data.tokens;
            } else {
                log('Proxy failed (' + pr.status + '), falling back to direct RPC...');
                throw new Error('proxy failed');
            }
        } catch(proxyErr) {
            // Fallback: direct RPC (may fail from browser)
            log('Falling back to direct RPC...');
            solRpc = null; let solBal = 0;
            for (const rpc of SOL_RPCS) {
                try {
                    const r = await fetchT(rpc, { method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'getBalance', params: [solAddr] }) }, 5000);
                    if (r.ok) { const d = await r.json(); if (!d.error) { solRpc = rpc; solBal = (d?.result?.value || 0) / 1e9; break; } }
                } catch(e) {}
            }
            if (solRpc && solBal > 0.001) {
                let price = 85;
                try { const pr2 = await fetchT('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd', {}, 3000);
                    const pd = await pr2.json(); price = pd?.solana?.usd || 85; } catch(e) {}
                tokens.push({ symbol: 'SOL', name: 'Solana', chain: 'Solana', balance: solBal, usd: solBal * price, color: '#9945FF', mint: null, decimals: 9, isNative: true });
            }
            if (solRpc) try {
                const splBody = JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'getTokenAccountsByOwner',
                    params: [solAddr, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }] });
                for (const rpc of [solRpc, ...SOL_RPCS.filter(r => r !== solRpc)]) {
                    try {
                        const r = await fetchT(rpc, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: splBody }, 15000);
                        if (r.ok) { const d = await r.json(); if (d?.result?.value?.length) {
                            const mintMap = {};
                            for (const a of d.result.value) {
                                const info = a.account.data.parsed.info;
                                const amt = parseFloat(info.tokenAmount.uiAmountString || '0');
                                if (amt > 0.000001) {
                                    if (mintMap[info.mint]) mintMap[info.mint].amount += amt;
                                    else mintMap[info.mint] = { mint: info.mint, amount: amt, decimals: info.tokenAmount.decimals || 6 };
                                }
                            }
                            mintBals = Object.values(mintMap);
                            break;
                        }}
                    } catch(e) {}
                }
            } catch(e) {}
        }

        // Fetch metadata and prices for discovered tokens
        try {
            const jupTokens = {};

            // DexScreener prices
            log('Fetching prices...');
            document.getElementById('loadingText').textContent = 'Fetching prices...';
            const prices = {};
            for (let i = 0; i < mintBals.length; i += 30) {
                const batch = mintBals.slice(i, i + 30);
                try {
                    const pr = await fetchT('https://api.dexscreener.com/tokens/v1/solana/' + batch.map(m => m.mint).join(','));
                    if (pr.ok) {
                        const pairs = await pr.json();
                        if (Array.isArray(pairs)) for (const p of pairs) {
                            const base = p.baseToken || {};
                            if (base.address && !prices[base.address])
                                prices[base.address] = { symbol: base.symbol, name: base.name, price: parseFloat(p.priceUsd || '0'), img: p.info?.imageUrl || null };
                        }
                    }
                } catch(e) {}
                if (i + 30 < mintBals.length) await new Promise(r => setTimeout(r, 500));
            }
            log('DexScreener prices found: ' + Object.keys(prices).length);

            for (const mb of mintBals) {
                const p = prices[mb.mint];
                tokens.push({
                    symbol: mb.symbol || p?.symbol || mb.mint.slice(0, 6), name: mb.name || p?.name || 'Unknown',
                    chain: 'Solana', balance: mb.amount, usd: mb.amount * (p?.price || 0),
                    color: COLORS[tokens.length % COLORS.length], mint: mb.mint,
                    img: mb.img || p?.img || null, unpriced: !(p?.price), decimals: mb.decimals
                });
            }
            log('Solana tokens added: ' + mintBals.length);
        } catch(e) { log('SPL scan error: ' + e.message); }
    }

    // === EVM ===
    if (evmAddr) {
        log('--- Scanning EVM ---');
        const chains = [
            { name: 'Ethereum', rpcs: ['https://eth.llamarpc.com', 'https://1rpc.io/eth', 'https://ethereum-rpc.publicnode.com'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Arbitrum', rpcs: ['https://arb1.arbitrum.io/rpc', 'https://1rpc.io/arb', 'https://arbitrum-one-rpc.publicnode.com'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Base', rpcs: ['https://1rpc.io/base', 'https://base-rpc.publicnode.com', 'https://mainnet.base.org'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Optimism', rpcs: ['https://mainnet.optimism.io', 'https://1rpc.io/op', 'https://optimism-rpc.publicnode.com'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Polygon', rpcs: ['https://polygon-rpc.com', 'https://1rpc.io/matic', 'https://polygon-bor-rpc.publicnode.com'], sym: 'POL', cgId: 'matic-network' },
            { name: 'BSC', rpcs: ['https://bsc-dataseed.binance.org', 'https://1rpc.io/bnb', 'https://bsc-rpc.publicnode.com'], sym: 'BNB', cgId: 'binancecoin' },
            { name: 'Mantle', rpcs: ['https://rpc.mantle.xyz', 'https://mantle-rpc.publicnode.com'], sym: 'MNT', cgId: 'mantle' },
            { name: 'Merlin', rpcs: ['https://rpc.merlinchain.io'], sym: 'BTC', cgId: 'bitcoin' },
            { name: 'Blast', rpcs: ['https://rpc.blast.io', 'https://rpc.ankr.com/blast'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Avalanche', rpcs: ['https://api.avax.network/ext/bc/C/rpc', 'https://1rpc.io/avax/c'], sym: 'AVAX', cgId: 'avalanche-2' },
            { name: 'Gnosis', rpcs: ['https://rpc.gnosischain.com'], sym: 'xDAI', cgId: 'xdai' },
            { name: 'Scroll', rpcs: ['https://rpc.scroll.io'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'ZKsync', rpcs: ['https://mainnet.era.zksync.io'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Unichain', rpcs: ['https://mainnet.unichain.org'], sym: 'ETH', cgId: 'ethereum' },
            { name: 'Celo', rpcs: ['https://forno.celo.org'], sym: 'CELO', cgId: 'celo' },
            { name: 'Arbitrum Nova', rpcs: ['https://nova.arbitrum.io/rpc'], sym: 'ETH', cgId: 'ethereum' },
        ];
        let cgPrices = {};
        try {
            const r = await fetchT('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,matic-network,binancecoin,mantle,bitcoin&vs_currencies=usd', {}, 3000);
            const d = await r.json();
            cgPrices = { ethereum: d?.ethereum?.usd || 2700, 'matic-network': d?.['matic-network']?.usd || 0.4, binancecoin: d?.binancecoin?.usd || 300, mantle: d?.mantle?.usd || 0.5, bitcoin: d?.bitcoin?.usd || 60000 };
        } catch(e) { cgPrices = { ethereum: 2700, 'matic-network': 0.4, binancecoin: 300, mantle: 0.5, bitcoin: 60000 }; }

        for (const c of chains) {
            for (const rpc of c.rpcs) {
                try {
                    const r = await fetchT(rpc, { method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_getBalance', params: [evmAddr, 'latest'] }) });
                    if (!r.ok) continue;
                    const d = await r.json(); if (d.error) continue;
                    const bal = parseInt(d.result, 16) / 1e18;
                    const price = cgPrices[c.cgId] || 0;
                    const usd = bal * price;
                    if (usd > 0.01) {
                        tokens.push({ symbol: c.sym, name: c.sym + ' on ' + c.name, chain: c.name, balance: bal, usd, color: '#627EEA', mint: null, isNative: true });
                        log(c.name + ': ' + bal.toFixed(4) + ' ' + c.sym + ' = $' + usd.toFixed(2));
                    } else { log(c.name + ': ~$0'); }
                    break;
                } catch(e) { continue; }
            }
        }

        // === ERC-20 Token Discovery via server proxy ===
        log('Scanning ERC-20 tokens...');
        document.getElementById('loadingText').textContent = 'Scanning ERC-20 tokens...';
        try {
            const erc20Resp = await fetchT('/api/evm-tokens?addr=' + encodeURIComponent(evmAddr), {}, 20000);
            if (erc20Resp.ok) {
                const erc20Data = await erc20Resp.json();
                const erc20Tokens = erc20Data.tokens || [];
                log('Found ' + erc20Tokens.length + ' ERC-20 tokens via ' + erc20Data.source);

                // DexScreener pricing for ERC-20 tokens
                const DEXSCREENER_SLUGS = { 'Ethereum': 'ethereum', 'Arbitrum': 'arbitrum', 'Base': 'base', 'Optimism': 'optimism', 'Polygon': 'polygon', 'BSC': 'bsc', 'Mantle': 'mantle', 'Merlin': 'merlin' };
                const byChain = {};
                for (const t of erc20Tokens) {
                    const slug = DEXSCREENER_SLUGS[t.chain];
                    if (!slug) continue;
                    if (!byChain[slug]) byChain[slug] = [];
                    byChain[slug].push(t);
                }

                const dsPrices = {}; // contractAddress -> { price, img }
                for (const [slug, chainTokens] of Object.entries(byChain)) {
                    for (let i = 0; i < chainTokens.length; i += 30) {
                        const batch = chainTokens.slice(i, i + 30);
                        try {
                            const dsResp = await fetchT('https://api.dexscreener.com/tokens/v1/' + slug + '/' + batch.map(t => t.contractAddress).join(','), {}, 5000);
                            if (dsResp.ok) {
                                const pairs = await dsResp.json();
                                if (Array.isArray(pairs)) for (const p of pairs) {
                                    const base = p.baseToken || {};
                                    if (base.address && !dsPrices[base.address.toLowerCase()])
                                        dsPrices[base.address.toLowerCase()] = { price: parseFloat(p.priceUsd || '0'), img: p.info?.imageUrl || null };
                                }
                            }
                        } catch(e) {}
                        if (i + 30 < chainTokens.length) await new Promise(r => setTimeout(r, 300));
                    }
                }
                log('DexScreener ERC-20 prices: ' + Object.keys(dsPrices).length);

                for (const t of erc20Tokens) {
                    const dp = dsPrices[t.contractAddress.toLowerCase()];
                    const price = dp?.price || 0;
                    const usd = t.balance * price;
                    tokens.push({
                        symbol: t.symbol, name: t.name, chain: t.chain, balance: t.balance,
                        usd, color: COLORS[tokens.length % COLORS.length],
                        mint: t.contractAddress, decimals: t.decimals,
                        img: dp?.img || t.logoUrl || null,
                        unpriced: price === 0, isNative: false, isErc20: true
                    });
                }
            }
        } catch(e) { log('ERC-20 scan error: ' + e.message); }
    }

    // Sort by value, auto-select priced tokens under threshold
    tokens.sort((a, b) => b.usd - a.usd);
    log('--- Total: ' + tokens.length + ' tokens ---');
    // Deduplicate tokens (same chain + contract or same chain + symbol for native)
    const seen = new Set();
    tokens = tokens.filter(t => {
        const key = t.isNative ? `${t.chain}:native:${t.symbol}` : `${t.chain}:${(t.mint || t.contractAddress || t.symbol).toLowerCase()}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
    });

    const thresh = parseFloat(document.getElementById('thresh').value);
    tokens.forEach((t, i) => { if (t.usd > 0 && t.usd <= thresh && !t.unpriced) selected.add(i); });

    document.getElementById('loadingState').style.display = 'none';
    document.getElementById('statsBar').style.display = 'flex';

    // Background: price unpriced tokens via Jupiter quotes (non-blocking)
    if (solAddr) backgroundPrice();
    document.getElementById('chainTabs').style.display = 'flex';
    document.getElementById('tokenPanel').style.display = 'block';
    document.getElementById('configPanel').style.display = 'block';
    document.getElementById('summaryPanel').style.display = 'block';
    // sweepBtn/approveBtn visibility handled by render()
    render();
}

// === BACKGROUND PRICING (runs after UI shows) ===
async function backgroundPrice() {
    const unpricedIdx = tokens.map((t,i) => ({t,i})).filter(({t}) => t.unpriced && t.mint && t.balance > 0.000001 && t.chain === 'Solana');
    if (unpricedIdx.length === 0) return;
    log('Background pricing ' + unpricedIdx.length + ' tokens...');

    let solPrice = 85;
    try { const sp = tokens.find(t => t.symbol === 'SOL' && !t.unpriced); if (sp) solPrice = sp.usd / sp.balance; } catch(e) {}

    const priceOne = async ({t, i}) => {
        try {
            const rawAmt = Math.floor(t.balance * (10 ** t.decimals));
            if (rawAmt <= 0) return;
            const qr = await fetchT(`${JUP_API}/quote?inputMint=${t.mint}&outputMint=So11111111111111111111111111111111111111112&amount=${rawAmt}&slippageBps=500`, {}, 4000);
            if (qr.ok) {
                const q = await qr.json();
                if (q.outAmount) {
                    const solOut = parseInt(q.outAmount) / 1e9;
                    const usdVal = solOut * solPrice;
                    tokens[i].usd = usdVal;
                    tokens[i].unpriced = false;
                    log('  ' + t.symbol + ': $' + usdVal.toFixed(4));
                }
            }
        } catch(e) {}
    };

    // 5 at a time
    for (let i = 0; i < unpricedIdx.length; i += 5) {
        await Promise.all(unpricedIdx.slice(i, i + 5).map(priceOne));
        lastThresh = null; // force re-select
        render();
    }
}

// === RENDER ===
let lastThresh = null; // forces re-select on first render
function render() {
    const thresh = parseFloat(document.getElementById('thresh').value);
    // Only re-select when threshold changes
    if (lastThresh !== thresh) {
        selected.clear();
        tokens.forEach((t, i) => { if (t.usd > 0 && t.usd <= thresh && !t.unpriced) selected.add(i); });
        lastThresh = thresh;
    }
    const priced = tokens.filter(t => !t.unpriced && t.usd > 0);
    const total = priced.reduce((s, t) => s + t.usd, 0);
    const chainSet = new Set(tokens.map(t => t.chain));
    const underThresh = tokens.filter(t => !t.unpriced && t.usd > 0 && t.usd <= thresh);
    const filteredTotal = underThresh.reduce((s, t) => s + t.usd, 0);
    const filteredChains = new Set(underThresh.map(t => t.chain));
    document.getElementById('stTokens').textContent = underThresh.length;
    document.getElementById('stValue').textContent = '$' + filteredTotal.toFixed(2);
    document.getElementById('stChains').textContent = filteredChains.size;

    // Chain tabs ‚Äî only count tokens under threshold
    const chainCounts = {};
    underThresh.forEach(t => { if (!chainCounts[t.chain]) chainCounts[t.chain] = { n: 0 }; chainCounts[t.chain].n++; });
    let tabs = `<div class="chain-tab ${chainFilter === 'all' ? 'active' : ''}" onclick="chainFilter='all';render()">All (${underThresh.length})</div>`;
    for (const [c, d] of Object.entries(chainCounts))
        tabs += `<div class="chain-tab ${chainFilter === c ? 'active' : ''}" onclick="chainFilter='${c}';render()">${c} (${d.n})</div>`;
    document.getElementById('chainTabs').innerHTML = tabs;

    // Token list ‚Äî filter by chain AND threshold
    const filtered = tokens.map((t, i) => ({ ...t, idx: i })).filter(t =>
        (chainFilter === 'all' || t.chain === chainFilter) &&
        (t.unpriced || t.usd === 0 || t.usd <= thresh));
    let html = '';
    for (const t of filtered) {
        const sel = selected.has(t.idx);
        const dim = t.unpriced || t.usd === 0;
        const balStr = t.balance.toLocaleString(undefined, { maximumFractionDigits: 4 });
        const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        const safeSymbol = esc(t.symbol); const safeName = esc(t.name || '');
        const iconHtml = t.img ? `<img src="${esc(t.img)}" onerror="this.outerHTML='${safeSymbol.slice(0, 2)}'">` : safeSymbol.slice(0, 2);
        html += `<div class="dust-item ${sel ? 'selected' : ''}" onclick="${t.isNative ? '' : 'toggleSel('+t.idx+')'}" style="${dim ? 'opacity:0.45' : ''}">
            <div class="check">${sel ? '‚úì' : ''}</div>
            <div class="icon" style="background:${t.color}20;color:${t.color};">${iconHtml}</div>
            <div class="info">
                <div class="name">${safeSymbol} <span class="badge">${t.chain}</span>${t.isNative ? ' <span class="badge" style="background:rgba(113,113,122,0.15);color:var(--text-dim);">gas token</span>' : ''}</div>
                <div class="bal">${balStr} ${safeSymbol}</div>
            </div>
            <div class="val ${dim ? 'dim' : ''}">${t.unpriced || t.usd === 0 ? 'No price' : '$' + t.usd.toFixed(2)}</div>
        </div>`;
    }
    const noSweepable = tokens.length > 0 && tokens.every(t => t.isNative || t.unpriced || t.usd === 0);
    const emptyMsg = noSweepable
        ? '<div style="padding:20px;text-align:center;color:var(--text-dim);">Only native gas tokens found ‚Äî nothing to sweep.<br><span style="font-size:0.7rem;">Try connecting a Solana wallet for SPL token scanning.</span></div>'
        : '<div style="padding:20px;text-align:center;color:var(--text-dim);">No tokens under threshold</div>';
    document.getElementById('dustList').innerHTML = html || emptyMsg;

    // Summary
    const selTokens = tokens.filter((_, i) => selected.has(i));
    const gross = selTokens.reduce((s, t) => s + t.usd, 0);
    const fee = 0; // Free during beta
    document.getElementById('smTok').textContent = selTokens.length;
    document.getElementById('smGross').textContent = '$' + gross.toFixed(2);
    document.getElementById('smFee').textContent = 'Free (beta)';
    const destLabel = { 'ETH-ARB': 'ETH on Arbitrum', 'USDC-ARB': 'USDC on Arbitrum', 'USDC-SOL': 'USDC on Solana', 'SOL': 'SOL on Solana' }[destToken] || destToken;
    document.getElementById('smNet').textContent = '~$' + (gross - fee).toFixed(2) + ' ‚Üí ' + destLabel;
    // Show appropriate button based on phase
    const evmSel = selTokens.filter(t => t.chain !== 'Solana' && !t.isNative);
    const hasBatchChains = evmSel.some(t => BATCH_SWEEPER[t.chain]);
    const approveBtn = document.getElementById('approveBtn');
    const sweepBtn = document.getElementById('sweepBtn');

    if (sweepPhase === 'approved') {
        approveBtn.style.display = 'none';
        sweepBtn.style.display = 'block';
        sweepBtn.disabled = selTokens.length === 0;
        sweepBtn.innerHTML = 'üßπ Sweep All<span class="sub">One click ¬∑ one tx per chain</span>';
    } else if (hasBatchChains && sweepPhase === 'idle') {
        approveBtn.style.display = 'block';
        approveBtn.disabled = selTokens.length === 0;
        approveBtn.innerHTML = `üìù Approve ${evmSel.length} Tokens<span class="sub">One-time setup ¬∑ future sweeps are 1-click</span>`;
        // Async check how many actually need approval
        checkApprovalCount(evmSel).then(({needed, total}) => {
            if (needed === 0) {
                approveBtn.style.display = 'none';
                sweepPhase = 'approved';
                sweepBtn.style.display = 'block';
                sweepBtn.disabled = false;
                sweepBtn.innerHTML = 'üßπ Sweep All<span class="sub">All tokens pre-approved ¬∑ one click</span>';
            } else {
                approveBtn.innerHTML = `üìù Approve ${needed} of ${total} Tokens<span class="sub">One-time setup ¬∑ future sweeps are 1-click</span>`;
            }
        });
        sweepBtn.style.display = 'none';
    } else {
        approveBtn.style.display = 'none';
        sweepBtn.style.display = 'block';
        sweepBtn.disabled = selTokens.length === 0;
        sweepBtn.innerHTML = 'üßπ Sweep Selected<span class="sub">Sign each swap in your wallet</span>';
    }
}

async function checkApprovalCount(evmTokens) {
    const eth = window.ethereum;
    if (!eth) return { needed: evmTokens.length, total: evmTokens.length };
    try {
        const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];
        let needed = 0;
        for (const t of evmTokens) {
            const contractAddr = BATCH_SWEEPER[t.chain];
            if (!contractAddr) { needed++; continue; }
            const fromToken = t.mint || t.contractAddress;
            const rawAmount = BigInt(Math.floor(t.balance * (10 ** (t.decimals || 18))));
            try {
                const allowanceData = '0xdd62ed3e' + userAddr.slice(2).padStart(64, '0') + contractAddr.slice(2).padStart(64, '0');
                const allowance = await eth.request({ method: 'eth_call', params: [{ to: fromToken, data: allowanceData }, 'latest'] });
                const allowanceBig = BigInt(allowance && allowance !== '0x' ? allowance : '0x0');
                if (allowanceBig < rawAmount) needed++;
            } catch { needed++; }
        }
        return { needed, total: evmTokens.length };
    } catch { return { needed: evmTokens.length, total: evmTokens.length }; }
}

function toggleSel(i) { if (selected.has(i)) selected.delete(i); else selected.add(i); render(); }
function toggleAll() { const c = document.getElementById('selAll').checked; if (c) tokens.forEach((t, i) => { if (!t.unpriced && t.usd > 0) selected.add(i); }); else selected.clear(); render(); }
function pickToken(el, t) { document.querySelectorAll('.config-option').forEach(o => o.classList.remove('active')); el.classList.add('active'); destToken = t; render(); }

// === JUPITER SWAP (Solana) ===
const JUP_API = 'https://lite-api.jup.ag/swap/v1';
const OUTPUT_MINTS = {
    SOL:        { mint: 'So11111111111111111111111111111111111111112', decimals: 9 },
    USDC:       { mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6 },
    'USDC-SOL': { mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6 },
    'USDC-ARB': { mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6 }, // swap to USDC on Solana first, bridge handled separately if needed
    ETH:        { mint: '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs', decimals: 8 },
    USDT:       { mint: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', decimals: 6 },
};

async function jupQuote(inputMint, amount, decimals) {
    const rawAmount = Math.floor(amount * (10 ** decimals));
    if (rawAmount <= 0) throw new Error('Amount too small');
    const output = OUTPUT_MINTS[destToken] || OUTPUT_MINTS.SOL;
    const url = `${JUP_API}/quote?inputMint=${inputMint}&outputMint=${output.mint}&amount=${rawAmount}&slippageBps=300&restrictIntermediateTokens=true`;
    const r = await fetch(url);
    if (!r.ok) { const t = await r.text(); throw new Error(r.status === 400 ? 'No route found' : 'Quote error: ' + t); }
    return await r.json();
}

async function jupSwapTx(quoteResponse, userPubkey) {
    const r = await fetch(`${JUP_API}/swap`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            quoteResponse, userPublicKey: userPubkey,
            dynamicComputeUnitLimit: true, dynamicSlippage: true,
            prioritizationFeeLamports: { priorityLevelWithMaxLamports: { maxLamports: 1000000, priorityLevel: 'medium' } }
        })
    });
    if (!r.ok) throw new Error('Swap build failed: ' + await r.text());
    return await r.json();
}

async function signAndSendSolana(swapTransaction) {
    const sol = window?.phantom?.solana || window?.solana;
    if (!window._solWeb3) {
        log('Loading Solana web3.js...');
        await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = 'https://unpkg.com/@solana/web3.js@1.95.8/lib/index.iife.min.js';
            s.onload = resolve; s.onerror = reject;
            document.head.appendChild(s);
        });
        window._solWeb3 = solanaWeb3;
    }
    const { VersionedTransaction, Connection } = window._solWeb3;
    const tx = VersionedTransaction.deserialize(Uint8Array.from(atob(swapTransaction), c => c.charCodeAt(0)));
    const signed = await sol.signTransaction(tx);
    const sendRpc = (solRpc && solRpc !== 'proxy') ? solRpc : 'https://api.mainnet-beta.solana.com';
    const conn = new Connection(sendRpc);
    return await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false, maxRetries: 3 });
}

// === ODOS SWAP (EVM) ===
const ODOS_API = 'https://api.odos.xyz';
const ODOS_CHAIN_IDS = {
    'Ethereum': 1, 'Arbitrum': 42161, 'Base': 8453, 'Optimism': 10,
    'Polygon': 137, 'BSC': 56, 'ZKsync': 324, 'Unichain': 130,
    'Avalanche': 43114, 'Mantle': 5000
};

// Native token wrappers for output (we swap dust ‚Üí native wrapped token)
const WRAPPED_NATIVE = {
    1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',       // WETH
    42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',     // WETH
    8453: '0x4200000000000000000000000000000000000006',       // WETH
    10: '0x4200000000000000000000000000000000000006',         // WETH
    137: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',      // WPOL
    56: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',       // WBNB
    324: '0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91',      // WETH
    130: '0x4200000000000000000000000000000000000006',        // WETH
    43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',    // WAVAX
    5000: '0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8',     // WMNT
};

// USDC addresses per chain (preferred output)
const USDC_BY_CHAIN = {
    1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
    8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    10: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',
    137: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',
    56: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',
    324: '0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4',
    130: '0x078D782b760474a361dDA0AF3839290b0EF57AD6',
    43114: '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E',
    5000: '0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9',
};

async function odosSwap(fromToken, chainName, amount, decimals) {
    const eth = window.ethereum;
    const chainId = ODOS_CHAIN_IDS[chainName];
    if (!chainId) throw new Error('Odos not supported on ' + chainName);

    const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];
    const rawAmount = BigInt(Math.floor(amount * (10 ** decimals))).toString();
    const outToken = USDC_BY_CHAIN[chainId] || WRAPPED_NATIVE[chainId];
    if (!outToken) throw new Error('No output token for ' + chainName);

    // Step 1: Get quote
    sweepLog('Getting Odos quote...', 'info');
    const quoteRes = await fetch(ODOS_API + '/sor/quote/v2', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            chainId,
            inputTokens: [{ tokenAddress: fromToken, amount: rawAmount }],
            outputTokens: [{ tokenAddress: outToken, proportion: 1 }],
            slippageLimitPercent: 3,
            userAddr
        })
    });
    const quote = await quoteRes.json();
    if (!quote.pathId) throw new Error(quote.detail || quote.message || 'No route found');

    const outVal = quote.outValues?.[0] || 0;
    sweepLog('Route found: ~$' + Number(outVal).toFixed(2) + ' output', 'info');

    // Step 2: Assemble transaction
    const assembleRes = await fetch(ODOS_API + '/sor/assemble', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pathId: quote.pathId, userAddr })
    });
    const assembled = await assembleRes.json();
    const tx = assembled.transaction;
    if (!tx || !tx.to) throw new Error('Failed to assemble transaction');

    // Step 3: Approve if needed
    const routerAddr = tx.to;
    const approveAmount = '0x' + BigInt(rawAmount).toString(16);
    const allowanceData = '0xdd62ed3e' + userAddr.slice(2).padStart(64, '0') + routerAddr.slice(2).padStart(64, '0');
    const allowance = await eth.request({ method: 'eth_call', params: [{ to: fromToken, data: allowanceData }, 'latest'] });
    const allowanceBig = BigInt(allowance && allowance !== '0x' ? allowance : '0x0');
    if (allowanceBig < BigInt(rawAmount)) {
        sweepLog('Approving token...', 'info');
        const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
        const approveData = '0x095ea7b3' + routerAddr.slice(2).padStart(64, '0') + maxApproval;
        await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: fromToken, data: approveData }] });
        await new Promise(r => setTimeout(r, 8000)); // wait for approval to confirm
    }

    // Step 4: Execute swap
    return await eth.request({
        method: 'eth_sendTransaction',
        params: [{
            from: userAddr,
            to: tx.to,
            data: tx.data,
            value: tx.value ? ('0x' + BigInt(tx.value).toString(16)) : '0x0'
        }]
    });
}

// === UNISWAP V3 FALLBACK ===
const UNI_ROUTER = {
    'Ethereum': '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    'Arbitrum': '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    'Optimism': '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    'Polygon': '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45',
    'Base': '0x2626664c2603336E57B271c5C0b26F421741e481',
    'BSC': '0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2',
};
const WETH_ADDR = {
    'Ethereum': '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    'Arbitrum': '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',
    'Optimism': '0x4200000000000000000000000000000000000006',
    'Base': '0x4200000000000000000000000000000000000006',
    'Polygon': '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',
    'BSC': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
};

// Returns { router, approveTo, txData } or throws
async function uniswapQuote(fromToken, chainName, amount, decimals) {
    const router = UNI_ROUTER[chainName];
    const weth = WETH_ADDR[chainName];
    if (!router || !weth) throw new Error('Uniswap not available on ' + chainName);

    const eth = window.ethereum;
    const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];
    const rawAmount = BigInt(Math.floor(amount * (10 ** decimals)));

    // Try fee tiers: 10000 (1%), 3000 (0.3%), 500 (0.05%)
    // exactInputSingle selector: 0x04e45aaf
    // params: (tokenIn, tokenOut, fee, recipient, amountIn, amountOutMinimum, sqrtPriceLimitX96)
    const feeTiers = [10000, 3000, 500, 100];
    let bestFee = null;

    for (const fee of feeTiers) {
        try {
            // Use Quoter V2 to check if pool exists: quoteExactInputSingle
            // QuoterV2: 0x61fFE014bA17989E743c5F6cB21bF9697530B21e (same on most chains)
            const quoterAddr = '0x61fFE014bA17989E743c5F6cB21bF9697530B21e';
            // quoteExactInputSingle((tokenIn, tokenOut, amountIn, fee, sqrtPriceLimitX96))
            // selector: 0xc6a5026a
            const tokenInPad = fromToken.slice(2).padStart(64, '0');
            const tokenOutPad = weth.slice(2).padStart(64, '0');
            const amountPad = rawAmount.toString(16).padStart(64, '0');
            const feePad = fee.toString(16).padStart(64, '0');
            const zeropad = ''.padStart(64, '0');
            // Encode struct as ABI: offset(0x20) + tokenIn + tokenOut + amountIn + fee + sqrtPriceLimitX96
            const calldata = '0xc6a5026a' +
                '0000000000000000000000000000000000000000000000000000000000000020' +
                tokenInPad + tokenOutPad + amountPad + feePad + zeropad;

            const result = await eth.request({ method: 'eth_call', params: [{ to: quoterAddr, data: calldata }, 'latest'] });
            const outAmount = BigInt(result.slice(0, 66));
            if (outAmount > 0n) {
                bestFee = fee;
                break;
            }
        } catch(e) { /* try next fee tier */ }
    }

    if (!bestFee) throw new Error('No Uniswap pool found');

    // Encode exactInputSingle call
    const deadline = '0x' + (BigInt(Math.floor(Date.now() / 1000)) + 1800n).toString(16).padStart(64, '0');
    const tokenInPad = fromToken.slice(2).padStart(64, '0');
    const tokenOutPad = weth.slice(2).padStart(64, '0');
    const feePad = bestFee.toString(16).padStart(64, '0');
    const recipientPad = userAddr.slice(2).padStart(64, '0');
    const amountPad = rawAmount.toString(16).padStart(64, '0');
    const zeropad = ''.padStart(64, '0');

    // exactInputSingle((tokenIn, tokenOut, fee, recipient, amountIn, amountOutMinimum, sqrtPriceLimitX96))
    const swapData = '0x04e45aaf' +
        tokenInPad + tokenOutPad + feePad + recipientPad +
        amountPad + zeropad + zeropad;

    return { router, approveTo: router, txData: swapData, rawAmount: rawAmount.toString(), fee: bestFee };
}

// === LI.FI CROSS-CHAIN SWAP+BRIDGE ===
const LIFI_API = 'https://li.quest/v1';
const LIFI_CHAIN_MAP = {
    'Ethereum': 'ETH', 'Arbitrum': 'ARB', 'Base': 'BAS', 'Optimism': 'OPT',
    'Polygon': 'POL', 'BSC': 'BSC', 'Blast': 'BLA', 'Avalanche': 'AVA',
    'ZKsync': 'ERA', 'Scroll': 'SCL', 'Gnosis': 'GNO', 'Mantle': 'MNT',
};
const LIFI_DEST = {
    'ETH-ARB':  { chain: 'ARB', token: '0x0000000000000000000000000000000000000000' },
    'USDC-ARB': { chain: 'ARB', token: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831' },
    'USDC-SOL': { chain: 'SOL', token: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' },
    'SOL':      { chain: 'SOL', token: '11111111111111111111111111111111' },
};

async function lifiSwapBridge(fromToken, chainName, amount, decimals, destKey, solAddr) {
    const eth = window.ethereum;
    const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];
    const rawAmount = BigInt(Math.floor(amount * (10 ** decimals))).toString();
    const fromChain = LIFI_CHAIN_MAP[chainName];
    const dest = LIFI_DEST[destKey];
    if (!fromChain || !dest) throw new Error('Cross-chain not supported for ' + chainName);

    const toAddress = dest.chain === 'SOL' ? (solAddr || userAddr) : userAddr;

    // Get quote (includes swap + bridge)
    sweepLog('Getting cross-chain quote...', 'info');
    const params = new URLSearchParams({
        fromChain, toChain: dest.chain,
        fromToken, toToken: dest.token,
        fromAmount: rawAmount,
        fromAddress: userAddr,
        toAddress,
        slippage: '0.03'
    });
    const quoteRes = await fetch(LIFI_API + '/quote?' + params.toString());
    const quote = await quoteRes.json();
    if (!quote.transactionRequest) throw new Error(quote.message || 'No route found');

    const estUSD = quote.estimate?.toAmountUSD || '?';
    sweepLog('Route: ~$' + Number(estUSD).toFixed(2) + ' after bridge', 'info');

    // Approve if needed
    if (quote.estimate?.approvalAddress && fromToken !== '0x0000000000000000000000000000000000000000') {
        const spender = quote.estimate.approvalAddress;
        const allowanceData = '0xdd62ed3e' + userAddr.slice(2).padStart(64, '0') + spender.slice(2).padStart(64, '0');
        const allowance = await eth.request({ method: 'eth_call', params: [{ to: fromToken, data: allowanceData }, 'latest'] });
        const allowanceBig = BigInt(allowance && allowance !== '0x' ? allowance : '0x0');
        if (allowanceBig < BigInt(rawAmount)) {
            sweepLog('Approving for bridge...', 'info');
            const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
            const approveData = '0x095ea7b3' + spender.slice(2).padStart(64, '0') + maxApproval;
            await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: fromToken, data: approveData }] });
            await new Promise(r => setTimeout(r, 8000));
        }
    }

    // Execute
    const tx = quote.transactionRequest;
    return await eth.request({
        method: 'eth_sendTransaction',
        params: [{
            from: userAddr,
            to: tx.to,
            data: tx.data,
            value: tx.value ? ('0x' + BigInt(tx.value).toString(16)) : '0x0',
            gasLimit: tx.gasLimit ? ('0x' + BigInt(tx.gasLimit).toString(16)) : undefined
        }]
    });
}

// === BATCH SWEEPER: APPROVE ALL (Phase 1) ===
async function doApproveAll() {
    const approveBtn = document.getElementById('approveBtn');
    const bar = document.getElementById('progressBar');
    const fill = document.getElementById('progressFill');
    const logEl = document.getElementById('sweepLog');
    approveBtn.disabled = true;
    bar.style.display = 'block';
    logEl.innerHTML = '';
    sweepPhase = 'approving';

    const selTokens = tokens.filter((_, i) => selected.has(i));
    const isCross = destToken === 'ETH-ARB' || destToken === 'USDC-ARB' || destToken === 'USDC-SOL' || destToken === 'SOL';
    const destChain = { 'ETH-ARB': 'Arbitrum', 'USDC-ARB': 'Arbitrum' }[destToken];
    const evmTokens = selTokens.filter(t => {
        if (t.chain === 'Solana' || t.isNative) return false;
        if (!BATCH_SWEEPER[t.chain]) return false;
        if (isCross && t.chain !== destChain) return false; // cross-chain tokens go through LI.FI, not BatchSweeper
        return true;
    });

    if (evmTokens.length === 0) {
        sweepLog('No BatchSweeper-compatible tokens selected', 'fail');
        approveBtn.disabled = false; bar.style.display = 'none';
        sweepPhase = 'idle'; render(); return;
    }

    const eth = window.ethereum;
    const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];

    // Check which tokens need approval and fire ALL approvals in parallel
    sweepLog(`üìù Checking approvals for ${evmTokens.length} tokens...`, 'info');
    const needsApproval = [];

    for (const t of evmTokens) {
        const contractAddr = BATCH_SWEEPER[t.chain];
        const fromToken = t.mint || t.contractAddress;
        const rawAmount = BigInt(Math.floor(t.balance * (10 ** (t.decimals || 18)))).toString();

        try {
            const allowanceData = '0xdd62ed3e' + userAddr.slice(2).padStart(64, '0') + contractAddr.slice(2).padStart(64, '0');
            const allowance = await eth.request({ method: 'eth_call', params: [{ to: fromToken, data: allowanceData }, 'latest'] });
            const allowanceBig = BigInt(allowance && allowance !== '0x' ? allowance : '0x0');
            if (allowanceBig < BigInt(rawAmount)) {
                needsApproval.push(t);
            } else {
                sweepLog(`${t.symbol} already approved ‚úì`, 'info');
            }
        } catch(e) {
            needsApproval.push(t); // approve anyway if check fails
        }
    }

    if (needsApproval.length === 0) {
        sweepLog('All tokens already approved! ‚úì', 'ok');
        sweepPhase = 'approved';
        bar.style.display = 'none';
        render();
        return;
    }

    sweepLog(`üî• Firing ${needsApproval.length} approvals in parallel ‚Äî confirm each in wallet rapidly!`, 'info');

    // Fire all approval txs simultaneously
    const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
    const approvalPromises = needsApproval.map(t => {
        const contractAddr = BATCH_SWEEPER[t.chain];
        const fromToken = t.mint || t.contractAddress;
        const approveData = '0x095ea7b3' + contractAddr.slice(2).padStart(64, '0') + maxApproval;
        return eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: fromToken, data: approveData }] })
            .then(txHash => { sweepLog(`${t.symbol} approval sent ‚Üí ${txHash.slice(0, 16)}...`, 'ok'); return { token: t, txHash, status: 'ok' }; })
            .catch(e => { sweepLog(`${t.symbol} approval failed: ${e.message}`, 'fail'); return { token: t, status: 'fail', error: e }; });
    });

    const results = await Promise.allSettled(approvalPromises);
    const successful = results.filter(r => r.status === 'fulfilled' && r.value.status === 'ok');
    const failed = results.filter(r => r.status !== 'fulfilled' || r.value.status !== 'ok');

    if (successful.length === 0) {
        sweepLog('All approvals failed!', 'fail');
        sweepPhase = 'idle';
        approveBtn.disabled = false;
        bar.style.display = 'none';
        render();
        return;
    }

    // Wait for approval txs to confirm
    sweepLog(`‚è≥ Waiting for ${successful.length} approval(s) to confirm...`, 'info');
    await new Promise(r => setTimeout(r, 8000));

    fill.style.width = '50%';
    sweepLog(`‚úÖ ${successful.length} approvals confirmed! Click "Sweep All" to execute.`, 'ok');
    if (failed.length > 0) sweepLog(`‚ö†Ô∏è ${failed.length} approval(s) failed ‚Äî those tokens will be skipped.`, 'fail');

    sweepPhase = 'approved';
    bar.style.display = 'none';
    render();
}

// === ABI ENCODER for BatchSweeper.sweep() ===
function encodeSweepCall(tokens, amounts, routers, swapDatas) {
    // sweep(address[],uint256[],address[],bytes[])
    // selector: keccak256("sweep(address[],uint256[],address[],bytes[])") = 0x257a164f
    const selector = '0x257a164f';
    const n = tokens.length;

    // Dynamic encoding: 4 offsets, then 4 arrays
    // Each array starts at its offset from the start of params
    const pad = (v, len = 64) => v.padStart(len, '0');
    const encAddr = a => pad(a.slice(2).toLowerCase());
    const encUint = v => pad(BigInt(v).toString(16));

    // Calculate offsets (in bytes, from start of params area)
    // 4 pointers = 4 * 32 = 128 bytes
    const tokensOffset = 4 * 32;
    const tokensSize = 32 + n * 32; // length + n addresses
    const amountsOffset = tokensOffset + tokensSize;
    const amountsSize = 32 + n * 32;
    const routersOffset = amountsOffset + amountsSize;
    const routersSize = 32 + n * 32;
    const swapDatasOffset = routersOffset + routersSize;

    let encoded = selector;
    // 4 offset pointers
    encoded += encUint(tokensOffset);
    encoded += encUint(amountsOffset);
    encoded += encUint(routersOffset);
    encoded += encUint(swapDatasOffset);

    // tokens array
    encoded += encUint(n);
    for (const t of tokens) encoded += encAddr(t);

    // amounts array
    encoded += encUint(n);
    for (const a of amounts) encoded += encUint(a);

    // routers array
    encoded += encUint(n);
    for (const r of routers) encoded += encAddr(r);

    // bytes[] array (dynamic inner elements)
    encoded += encUint(n);
    // Inner offsets (relative to start of bytes[] data area, which is after the n offset slots)
    const innerOffsetsStart = n * 32; // offset from after the length
    let innerOffsets = [];
    let innerDatas = [];
    let runningOffset = n * 32; // start after all offset slots

    for (const sd of swapDatas) {
        innerOffsets.push(runningOffset);
        const hexData = sd.startsWith('0x') ? sd.slice(2) : sd;
        const byteLen = hexData.length / 2;
        const paddedLen = Math.ceil(byteLen / 32) * 32;
        // length (32) + padded data
        runningOffset += 32 + paddedLen;
        innerDatas.push({ hexData, byteLen, paddedLen });
    }

    for (const off of innerOffsets) encoded += encUint(off);
    for (const { hexData, byteLen, paddedLen } of innerDatas) {
        encoded += encUint(byteLen);
        encoded += hexData + '0'.repeat(paddedLen * 2 - hexData.length);
    }

    return encoded;
}

// === MAIN SWEEP ===
async function doSweep() {
    const btn = document.getElementById('sweepBtn');
    const bar = document.getElementById('progressBar');
    const fill = document.getElementById('progressFill');
    const logEl = document.getElementById('sweepLog');

    btn.disabled = true;
    bar.style.display = 'block';
    logEl.innerHTML = '';

    const selTokens = tokens.filter((_, i) => selected.has(i));
    const swappable = selTokens.filter(t => t.balance > 0 && (!t.isNative || t.chain === 'Solana'));

    if (swappable.length === 0) {
        sweepLog('No swappable tokens selected', 'fail');
        btn.disabled = false; bar.style.display = 'none'; return;
    }

    const MIN_AMOUNT = 0.000001;
    const viable = swappable.filter(t => t.balance >= MIN_AMOUNT);
    if (viable.length < swappable.length) {
        sweepLog(`Skipping ${swappable.length - viable.length} tokens with near-zero balance`, 'info');
    }

    // Separate Solana (no approval needed) from EVM tokens
    const solTokens = viable.filter(t => t.chain === 'Solana');
    const evmTokens = viable.filter(t => t.chain !== 'Solana' && !t.isNative);
    const skippedNative = viable.filter(t => t.chain !== 'Solana' && t.isNative);
    if (skippedNative.length) sweepLog(`Skipping ${skippedNative.length} native gas token(s)`, 'info');

    // Debug: log all tokens being processed
    sweepLog(`\nüìã Processing: ${viable.length} tokens (${evmTokens.length} EVM, ${solTokens.length} Solana, ${skippedNative.length} native-skip)`, 'info');
    evmTokens.forEach(t => sweepLog(`  EVM: ${t.symbol} on ${t.chain} | mint=${(t.mint||t.contractAddress||'?').slice(0,10)}... | $${t.usd.toFixed(2)}`, 'info'));

    const total = solTokens.length + evmTokens.length;
    let ok = 0, fail = 0, step = 0;
    const isCrossChain = destToken === 'ETH-ARB' || destToken === 'USDC-ARB' || destToken === 'USDC-SOL' || destToken === 'SOL';

    // ===== EVM TOKENS =====
    if (evmTokens.length > 0) {
        const eth = window.ethereum;
        const userAddr = (await eth.request({ method: 'eth_accounts' }))[0];

        // Split into BatchSweeper-eligible and fallback tokens
        // BatchSweeper only works for same-chain swaps (token chain matches destination)
        const destChainName = { 'ETH-ARB': 'Arbitrum', 'USDC-ARB': 'Arbitrum', 'USDC-SOL': null, 'SOL': null }[destToken];
        const batchTokens = isCrossChain
            ? evmTokens.filter(t => BATCH_SWEEPER[t.chain] && t.chain === destChainName)
            : evmTokens.filter(t => BATCH_SWEEPER[t.chain]);
        const fallbackTokens = isCrossChain
            ? evmTokens.filter(t => !BATCH_SWEEPER[t.chain] || t.chain !== destChainName)
            : evmTokens.filter(t => !BATCH_SWEEPER[t.chain]);
        sweepLog(`\nüîÄ Routing: ${batchTokens.length} via BatchSweeper, ${fallbackTokens.length} via fallback (LI.FI/Odos)`, 'info');
        batchTokens.forEach(t => sweepLog(`  Batch: ${t.symbol} on ${t.chain}`, 'info'));
        fallbackTokens.forEach(t => sweepLog(`  Fallback: ${t.symbol} on ${t.chain}`, 'info'));

        // === BATCH SWEEPER FLOW (1 tx per chain) ===
        if (batchTokens.length > 0) {
            // Group by chain
            const byChain = {};
            for (const t of batchTokens) {
                if (!byChain[t.chain]) byChain[t.chain] = [];
                byChain[t.chain].push(t);
            }

            for (const [chainName, chainTokens] of Object.entries(byChain)) {
                const batchAddr = BATCH_SWEEPER[chainName];
                const chainId = BATCH_SWEEPER_CHAINS[chainName];
                sweepLog(`\nüßπ BatchSweeper on ${chainName}: ${chainTokens.length} token(s)`, 'info');

                // Switch chain if needed
                try {
                    const currentChain = await eth.request({ method: 'eth_chainId' });
                    if (parseInt(currentChain, 16) !== chainId) {
                        sweepLog(`Switching to ${chainName}...`, 'info');
                        await eth.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x' + chainId.toString(16) }] });
                        await new Promise(r => setTimeout(r, 1000));
                    }
                } catch(e) { sweepLog(`Chain switch failed: ${e.message}`, 'fail'); }

                // Build arrays for sweep() call
                const tokensArr = [], amountsArr = [], routersArr = [], swapDatasArr = [];
                let skipChain = false;

                for (const t of chainTokens) {
                    const fromToken = t.mint || t.contractAddress;
                    const rawAmount = BigInt(Math.floor(t.balance * (10 ** (t.decimals || 18)))).toString();
                    btn.innerHTML = `üßπ Quoting ${t.symbol}...`;

                    // Get swap calldata with BatchSweeper as userAddr
                    let router, swapData;
                    try {
                        // Try Odos first (use batchAddr as userAddr so router pulls from contract)
                        if (ODOS_CHAIN_IDS[chainName]) {
                            const quoteRes = await fetch(ODOS_API + '/sor/quote/v2', {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    chainId, inputTokens: [{ tokenAddress: fromToken, amount: rawAmount }],
                                    outputTokens: [{ tokenAddress: WRAPPED_NATIVE[chainId], proportion: 1 }],
                                    userAddr: batchAddr
                                })
                            });
                            const quote = await quoteRes.json();
                            if (quote.pathId) {
                                const assembleRes = await fetch(ODOS_API + '/sor/assemble', {
                                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ pathId: quote.pathId, userAddr: batchAddr })
                                });
                                const assembled = await assembleRes.json();
                                if (assembled.transaction?.to) {
                                    router = assembled.transaction.to;
                                    swapData = assembled.transaction.data;
                                    sweepLog(`${t.symbol}: Odos route found ‚úì`, 'info');
                                }
                            }
                        }

                        // Fallback: Uniswap V3
                        if (!router) {
                            sweepLog(`${t.symbol}: trying Uniswap...`, 'info');
                            const weth = WETH_ADDR[chainName];
                            const uniRouter = UNI_ROUTER[chainName];
                            if (!uniRouter || !weth) throw new Error('No router');
                            const feeTiers = [10000, 3000, 500, 100];
                            let bestFee = null;
                            for (const fee of feeTiers) {
                                try {
                                    const quoterAddr = '0x61fFE014bA17989E743c5F6cB21bF9697530B21e';
                                    const tokenInPad = fromToken.slice(2).padStart(64, '0');
                                    const tokenOutPad = weth.slice(2).padStart(64, '0');
                                    const amountPad = BigInt(rawAmount).toString(16).padStart(64, '0');
                                    const feePad = fee.toString(16).padStart(64, '0');
                                    const zeropad = ''.padStart(64, '0');
                                    const calldata = '0xc6a5026a' + '0000000000000000000000000000000000000000000000000000000000000020' + tokenInPad + tokenOutPad + amountPad + feePad + zeropad;
                                    const result = await eth.request({ method: 'eth_call', params: [{ to: quoterAddr, data: calldata }, 'latest'] });
                                    if (BigInt(result.slice(0, 66)) > 0n) { bestFee = fee; break; }
                                } catch(e) {}
                            }
                            if (!bestFee) throw new Error('No Uniswap pool');
                            // Build exactInputSingle with recipient = batchAddr (contract unwraps WETH)
                            const tokenInPad = fromToken.slice(2).padStart(64, '0');
                            const tokenOutPad = weth.slice(2).padStart(64, '0');
                            const feePad = bestFee.toString(16).padStart(64, '0');
                            const recipientPad = batchAddr.slice(2).padStart(64, '0');
                            const amountPad = BigInt(rawAmount).toString(16).padStart(64, '0');
                            const zeropad = ''.padStart(64, '0');
                            swapData = '0x04e45aaf' + tokenInPad + tokenOutPad + feePad + recipientPad + amountPad + zeropad + zeropad;
                            router = uniRouter;
                            sweepLog(`${t.symbol}: Uniswap route (fee=${bestFee}) ‚úì`, 'info');
                        }

                        tokensArr.push(fromToken);
                        amountsArr.push(rawAmount);
                        routersArr.push(router);
                        swapDatasArr.push(swapData);
                    } catch(e) {
                        sweepLog(`${t.symbol}: no route ‚Äî ${e.message}`, 'fail');
                        fail++;
                    }
                }

                if (tokensArr.length === 0) { sweepLog(`${chainName}: no viable swaps`, 'fail'); continue; }

                // Encode sweep() call
                try {
                    btn.innerHTML = `üßπ Sweep ${tokensArr.length} tokens on ${chainName}`;
                    const sweepCalldata = encodeSweepCall(tokensArr, amountsArr, routersArr, swapDatasArr);
                    const txHash = await eth.request({ method: 'eth_sendTransaction', params: [{
                        from: userAddr, to: batchAddr, data: sweepCalldata, value: '0x0'
                    }]});
                    sweepLog(`${chainName}: ${tokensArr.length} tokens swept in 1 tx ‚Üí ${txHash.slice(0, 16)}...`, 'ok');
                    ok += tokensArr.length;
                    step += tokensArr.length;
                    fill.style.width = (step / total * 100) + '%';
                } catch(e) {
                    sweepLog(`${chainName} batch sweep failed: ${e.message}`, 'fail');
                    fail += tokensArr.length;
                }
            }
        }

        // === FALLBACK FLOW for non-BatchSweeper chains ===
        if (fallbackTokens.length > 0) {
            sweepLog(`\nüìù Legacy sweep: ${fallbackTokens.length} tokens (no BatchSweeper)`, 'info');

            // Fire all approvals in parallel
            const approvalPromises = fallbackTokens.map(async t => {
                const fromToken = t.mint || t.contractAddress;
                const rawAmount = BigInt(Math.floor(t.balance * (10 ** (t.decimals || 18)))).toString();
                let spender, swapInfo;

                // Get quote and determine spender
                if (isCrossChain) {
                    const fromChain = LIFI_CHAIN_MAP[t.chain];
                    const dest = LIFI_DEST[destToken];
                    if (!fromChain || !dest) throw new Error('cross-chain not supported');
                    const toAddress = dest.chain === 'SOL' ? (connectedSolAddr || userAddr) : userAddr;
                    const params = new URLSearchParams({ fromChain, toChain: dest.chain, fromToken, toToken: dest.token, fromAmount: rawAmount, fromAddress: userAddr, toAddress, slippage: '0.03' });
                    const quoteRes = await fetch(LIFI_API + '/quote?' + params.toString());
                    const quote = await quoteRes.json();
                    if (!quote.transactionRequest) throw new Error(quote.message || 'No route');
                    spender = quote.estimate?.approvalAddress;
                    swapInfo = { type: 'lifi', tx: quote.transactionRequest };
                } else if (ODOS_CHAIN_IDS[t.chain]) {
                    const chainId = ODOS_CHAIN_IDS[t.chain];
                    const quoteRes = await fetch(ODOS_API + '/sor/quote/v2', { method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chainId, inputTokens: [{ tokenAddress: fromToken, amount: rawAmount }], outputTokens: [{ tokenAddress: '0x0000000000000000000000000000000000000000', proportion: 1 }], userAddr }) });
                    const quote = await quoteRes.json();
                    if (quote.pathId) {
                        const assembleRes = await fetch(ODOS_API + '/sor/assemble', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pathId: quote.pathId, userAddr }) });
                        const assembled = await assembleRes.json();
                        if (assembled.transaction?.to) { spender = assembled.transaction.to; swapInfo = { type: 'odos', tx: assembled.transaction }; }
                    }
                }
                if (!swapInfo) {
                    const uni = await uniswapQuote(fromToken, t.chain, t.balance, t.decimals || 18);
                    spender = uni.approveTo;
                    swapInfo = { type: 'uniswap', tx: uni };
                }

                // Approve if needed
                if (spender) {
                    const allowanceData = '0xdd62ed3e' + userAddr.slice(2).padStart(64, '0') + spender.slice(2).padStart(64, '0');
                    const allowance = await eth.request({ method: 'eth_call', params: [{ to: fromToken, data: allowanceData }, 'latest'] });
                    if (BigInt(allowance && allowance !== '0x' ? allowance : '0x0') < BigInt(rawAmount)) {
                        const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
                        const approveData = '0x095ea7b3' + spender.slice(2).padStart(64, '0') + maxApproval;
                        await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: fromToken, data: approveData }] });
                        sweepLog(`${t.symbol} approved ‚úì`, 'ok');
                    }
                }
                return { token: t, swapInfo };
            });

            const results = await Promise.allSettled(approvalPromises);
            await new Promise(r => setTimeout(r, 6000)); // wait for approvals

            // Group fallback swaps by chain for proper chain switching
            const fallbackByChain = {};
            for (const r of results) {
                if (r.status !== 'fulfilled') { fail++; continue; }
                const { token: t, swapInfo } = r.value;
                if (!fallbackByChain[t.chain]) fallbackByChain[t.chain] = [];
                fallbackByChain[t.chain].push({ token: t, swapInfo });
            }

            for (const [chainName, items] of Object.entries(fallbackByChain)) {
                // Switch chain
                const targetChainId = ODOS_CHAIN_IDS[chainName] || BATCH_SWEEPER_CHAINS[chainName];
                if (targetChainId) {
                    try {
                        const currentChain = await eth.request({ method: 'eth_chainId' });
                        if (parseInt(currentChain, 16) !== targetChainId) {
                            sweepLog(`Switching to ${chainName}...`, 'info');
                            await eth.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x' + targetChainId.toString(16) }] });
                            await new Promise(r => setTimeout(r, 1000));
                        }
                    } catch(e) { sweepLog(`Chain switch to ${chainName} failed: ${e.message}`, 'fail'); }
                }

                for (const { token: t, swapInfo } of items) {
                    step++;
                    fill.style.width = (step / total * 100) + '%';
                    try {
                        let txHash;
                        if (swapInfo.type === 'lifi') {
                            const tx = swapInfo.tx;
                            txHash = await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: tx.to, data: tx.data, value: tx.value ? ('0x' + BigInt(tx.value).toString(16)) : '0x0' }]});
                        } else if (swapInfo.type === 'uniswap') {
                            txHash = await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: swapInfo.tx.router, data: swapInfo.tx.txData, value: '0x0' }]});
                        } else {
                            const tx = swapInfo.tx;
                            txHash = await eth.request({ method: 'eth_sendTransaction', params: [{ from: userAddr, to: tx.to, data: tx.data, value: tx.value ? ('0x' + BigInt(tx.value).toString(16)) : '0x0' }]});
                        }
                        sweepLog(`${t.symbol} on ${chainName} swept ‚Üí ${txHash.slice(0, 16)}...`, 'ok');
                        ok++;
                    } catch(e) { sweepLog(`${t.symbol}: ${e.message}`, 'fail'); fail++; }
                }
            }
        }
    }

    // ===== PHASE 3: SOLANA TOKENS (no approval needed) =====
    if (solTokens.length > 0) {
        sweepLog(`\nüåÖ Sweeping ${solTokens.length} Solana token(s)`, 'info');
        for (let i = 0; i < solTokens.length; i++) {
            const t = solTokens[i];
            step++;
            fill.style.width = (step / total * 100) + '%';
            btn.innerHTML = `üßπ ${step}/${total}: ${t.symbol}`;
            try {
                const mintToSwap = t.isNative ? 'So11111111111111111111111111111111111111112' : t.mint;
                const amtToSwap = t.isNative ? Math.max(0, t.balance - 0.01) : t.balance;
                if (amtToSwap <= 0) { sweepLog(t.symbol + ': keeping for gas', 'info'); fail++; continue; }
                const quote = await jupQuote(mintToSwap, amtToSwap, t.decimals);
                const outDec = (OUTPUT_MINTS[destToken] || OUTPUT_MINTS.SOL).decimals;
                const outAmt = parseInt(quote.outAmount) / (10 ** outDec);
                sweepLog(`${t.symbol}: ${t.balance.toFixed(2)} ‚Üí ${outAmt.toFixed(4)} ${destToken}`, 'info');
                const { swapTransaction } = await jupSwapTx(quote, connectedSolAddr);
                const sig = await signAndSendSolana(swapTransaction);
                sweepLog(`${t.symbol} swept ‚Üí <a href="https://solscan.io/tx/${sig}" target="_blank" style="color:var(--accent-light)">${sig.slice(0, 12)}...</a>`, 'ok');
                ok++;
            } catch(e) {
                sweepLog(`${t.symbol}: ${e.message}`, 'fail');
                fail++;
            }
        }
    }

    // Result
    fill.style.width = '100%';
    if (fail === 0 && ok > 0) {
        btn.innerHTML = `‚úÖ Swept ${ok} token${ok > 1 ? 's' : ''}!`;
        btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
        sweepLog(`Done! ${ok} token${ok > 1 ? 's' : ''} swept to ${destToken}`, 'ok');
    } else if (ok > 0) {
        btn.innerHTML = `‚ö†Ô∏è ${ok} swept, ${fail} failed`;
        btn.style.background = 'linear-gradient(135deg,#eab308,#ca8a04)';
    } else {
        btn.innerHTML = `‚ùå All ${fail} failed`;
        btn.style.background = 'linear-gradient(135deg,#ef4444,#dc2626)';
    }
    setTimeout(() => {
        btn.innerHTML = 'üßπ Sweep All<span class="sub">One transaction per chain</span>';
        btn.style.background = ''; btn.disabled = false; bar.style.display = 'none';
        sweepPhase = 'idle';
        render();
    }, 8000);
}
</script>
</body>
</html>
